let TranslationOrder,customErrorHandler,User,crypto;_47b‍.x([["default",()=>_47b‍.o]]);_47b‍.w("../../models/tralationOrders",[["default",["TranslationOrder"],function(v){TranslationOrder=v}]]);_47b‍.w("../../errorHandler",[["customErrorHandler",["customErrorHandler"],function(v){customErrorHandler=v}]]);_47b‍.w("../../models/user",[["default",["User"],function(v){User=v}]]);_47b‍.w("crypto",[["default",["crypto"],function(v){crypto=v}]]);




const translationController = {
  async addOrder(req, res, next) {
    try {
      const {
        name,
        email,
        phone,
        country,
        websiteId,
        assignmentId,
        service_req,
        sourceLanguage,
        targetlanguage,
        your_words,
        certification,
        message,
        notarization,
        deadline,
        status,
      } = req.body;
      let user;
      try {
        user = await User.findOne({ email });
        if (!user) {
          const password = crypto.randomBytes(5).toString("hex");
          user = await User.create({
            name,
            email,
            password,
            country,
            phone,
          });
        }
      } catch (err) {
        _47b‍.g.console.log(err);
        return next(customErrorHandler.serverError());
      }
      const filesUrl = req.files.map((e) => e.path);
      const order = await TranslationOrder.create({
        userId: user._id,
        phone,
        service_req,
        sourceLanguage,
        targetlanguage,
        your_words,
        certification,
        message,
        notarization,
        deadline,
        country,
        websiteId,
        assignmentId,
        status,
        ...(filesUrl.length && { files: filesUrl }),
      });
      if (!order) {
        return next(customErrorHandler.emptyData());
      }
      res
        .status(200)
        .json({ message: "Order Created SuccessFully", data: order });
    } catch (e) {
      _47b‍.g.console.log(e);
      next(customErrorHandler.serverError(e));
    }
  },
  async getOrders(req, res, next) {
    const { page, row } = req.query;
    const limit = +(row ? (row < 5 ? 5 : row) : 5);
    const skip = +(page < 0 ? 0 : limit * page);
    try {
      const count = await TranslationOrder.countDocuments({ });
      const orders = await TranslationOrder.find({}, null, {
        limit,
        skip,
        sort: {
          createdAt: -1,
        },
      }).populate("userId", "name email image");
      if (!orders) {
        return next(customErrorHandler.emptyData());
      }
      res.status(200).json({ data: orders, total: count });
    } catch (error) {
      _47b‍.g.console.log(error);
    }
  },
  async getOrderById(req, res, next) {
    const { id } = req.params;
    try {
      const order = await TranslationOrder.findById(id).populate(
        "userId",
        "name email"
      );
      if (!order) {
        return next(customErrorHandler.emptyData());
      }
      res.status(200).json({ data: order });
    } catch (error) {
      return next(customErrorHandler.serverError());
    }
  },
  async getOrdersofUser(req, res, next) {
    const { id } = req.params;
    const { page, row } = req.query;
    const limit = +(row ? (row < 5 ? 5 : row) : 5);
    const skip = +(page < 0 ? 0 : limit * page);

    try {
      const count = await TranslationOrder.countDocuments({ userId: id });
      const order = await TranslationOrder.find({ userId: id }, "-__v", {
        limit,
        skip,
      });
      if (!order || !count) {
        return next(customErrorHandler.emptyData());
      }
      res.status(200).json({ data: order, total: count });
    } catch (err) {
      _47b‍.g.console.log(err);
      return next(customErrorHandler.serverError(err));
    }
  },
  async updateOrder(req, res, next) {
    try {
      const {
        service_req,
        sourceLanguage,
        targetlanguage,
        your_words,
        certification,
        message,
        notarization,
        deadline,
        country,
        phone,
        status,
      } = req.body;
      const filesUrl = req.files.map((e) => e.path);
      const order = await TranslationOrder.findByIdAndUpdate(
        req.params.id,
        {
          ...(service_req && { service_req }),
          ...(sourceLanguage && { sourceLanguage }),
          ...(targetlanguage && { targetlanguage }),
          ...(your_words && { your_words }),
          ...(deadline && { deadline }),
          ...(certification && { certification }),
          ...(message && { message }),
          ...(country && { country }),
          ...(notarization && { notarization }),
          ...(status && { status }),
          ...(phone && { phone }),
          ...(filesUrl.length && { files: filesUrl }),
        },
        { new: true, runValidators: true }
      ).populate("userId", "name email image phone");
      if (!order) {
        return next(customErrorHandler.emptyData("Could't updated"));
      }
      res
        .status(201)
        .json({ message: "Order Updated SuccessFully", data: order });
    } catch (e) {
      _47b‍.g.console.log(e);
      next(customErrorHandler.serverError(e));
    }
  },
   async chatsOrder(req, res, next){
     try {
       const data = await TranslationOrder.aggregate([
         {
           $lookup: {
             form: "messages",
             as: "messages",
             let: { id: "$_id" },
             pipeline: [
               {
                 $match: {
                   $expr: { $eq: ["$$id", "$orderId"] },
                 },
               },
             ],
           },
         },
       ]);
       if (!data) {
         return res.json({data:''});
       }
       res.status(200).json({data});
     } catch (er) {
       _47b‍.g.console.log(er)
       return next(customErrorHandler.serverError(er));
     }
    

    
     

  }
};
_47b‍.d(translationController);
