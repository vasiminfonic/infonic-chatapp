let path,customErrorHandler,Message,User;_ad3‍.x([["default",()=>_ad3‍.o]]);_ad3‍.w("path",[["default",["path"],function(v){path=v}]]);_ad3‍.w("../../errorHandler",[["customErrorHandler",["customErrorHandler"],function(v){customErrorHandler=v}]]);_ad3‍.w("../../models/message",[["default",["Message"],function(v){Message=v}]]);_ad3‍.w("../../models/user",[["default",["User"],function(v){User=v}]]);





const messageController = {
    async getMessages(req, res, next){
        const { sender, receiver } = req.query;
        try{
            const message = await Message.find({$or: [{$and: [{sender}, {receiver}]}, {$and: [{sender: receiver}, {receiver: sender}]}]}).populate('sender').sort({"createdAt": -1}).limit(10)
            if(!message){
                return next(customErrorHandler.serverError("data is empty"))
            }
            res.status(200).json({data: message});
        }catch(err){
            _ad3‍.g.console.log(err);
            return next(customErrorHandler.serverError());   
        }
    },
    async getAllMessages(req, res, next){
        try{
           const messages = await Message.find().sort({createdAt: 1}).populate('sender','name').map(ele=>{
               return ele.map(el=>{
               
                return({
                    _id: el._id,
                    message: el.message,
                    sender: el.sender
                })
               }
            )
           })
           if(!messages){
            return next(customErrorHandler.serverError())
           }
           res.status(200).json(messages)
        }catch(err){
          return next(customErrorHandler.serverError());
        }
    },
    async download(req, res, next){
        const { file } = req.params;
        try{
            const fileurl = path.join(__dirname, `../../uploads/${file}`)
           res.download(fileurl);
        }catch(err){
        
          return next(customErrorHandler.serverError());
        }
    },
    async getMessageUsers(req, res, next){
        try{
           const messages = await Message.find().distinct('sender');

        //    const valeu = messages.map(async element => {
           const data = await User.find({_id: {$in: messages}})
        // });
        res.status(200).json(data);

           
        }catch(err){
            _ad3‍.g.console.log(err);
          return next(customErrorHandler.serverError());
        }
    },
    async setSeenMessage(req, res, next){
        const { id } = req.params
        try{
           const seen = await Message.updateMany({sender: id}, {$set:{seen: true}});
            if(!seen){
            return next(customErrorHandler.serverError())
           }
           res.status(200).json({message: 'done'});
        }catch(err){
            _ad3‍.g.console.log(err)
          return next(customErrorHandler.serverError());
        }
    },
    async unseenMessage(req, res, next){
        const { id } = req.params;
        
        try{
           const seen = await Message.find({$and: [{sender:{$ne: id}}, {seen: false}]}).sort({createdAt: 1}).populate('sender',"_id name email");
            if(!seen){
            return next(customErrorHandler.serverError())
           }
           res.status(200).json({data: seen});
        }catch(err){
            _ad3‍.g.console.log(err)
          return next(customErrorHandler.serverError());
        }
    }
}

_ad3‍.d(messageController);