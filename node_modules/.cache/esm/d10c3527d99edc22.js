let mongoose,SERVER_Path,Translation;_d99‍.x([["default",()=>_d99‍.o]]);_d99‍.w("mongoose",[["default",["mongoose"],function(v){mongoose=v}]]);_d99‍.w("../config",[["SERVER_Path",["SERVER_Path"],function(v){SERVER_Path=v}]]);_d99‍.w("../models/tralationOrders",[["default",["Translation"],function(v){Translation=v}]]);





const messageSchema = mongoose.Schema(
  {
    message: String,
    type: { type: String, default: "user" },
    file: [{ type: String, get: (file) => `${SERVER_Path}${file}` }],
    sender: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    receiver: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    orderId: { type: mongoose.Schema.Types.ObjectId, ref: "TranslationOrder" },
    seen: { type: Boolean, default: false },
  },
  { timestamps: true, toJSON: { getters: true }, id: false }
);


messageSchema.statics.create =async(content, sender, type, file, receiver, order) => {
    let msg = new messageModal({
        message: content,
        type: type,
        sender: sender,
        receiver: receiver,
        ...(file && {file: file}),
        ...(order && {orderId: order})
    });
    
    const isMessage = await messageModal.exists({ orderId: order })
    const saveMsg = msg.save();
    if (!isMessage){
      await Translation.findByIdAndUpdate(order, {status: 'await'});
    } 
    return saveMsg;
}

const messageModal = mongoose.model("Message", messageSchema, 'messages');

_d99‍.d(messageModal);