let jwt,joi,JWTSTRING,customErrorHandler,User;_639‍.x([["default",()=>_639‍.o]]);_639‍.w("jsonwebtoken",[["default",["jwt"],function(v){jwt=v}]]);_639‍.w("joi",[["default",["joi"],function(v){joi=v}]]);_639‍.w("../../config",[["JWTSTRING",["JWTSTRING"],function(v){JWTSTRING=v}]]);_639‍.w("../../errorHandler",[["customErrorHandler",["customErrorHandler"],function(v){customErrorHandler=v}]]);_639‍.w("../../models/user",[["default",["User"],function(v){User=v}]]);






const userController = {
    async getUser(req, res, next) {
        const { authorization } = req.headers;
        const token = authorization.split(' ')[1]

        try {
            const { data: { _id } = {} } = jwt.verify(token, JWTSTRING)
            _639‍.g.console.log(_id);
            const user = await User.findOne({ _id }, '-password -updatedAt -__v ');
            if (!user) {
                return next(customErrorHandler.wrongCredentials())
            }
            res.status(200).json({ data: user });
        } catch (err) {
            return next(customErrorHandler.serverError(err));
        }
    },

    async getAdmin(req, res, next) {
        try {
            const admin = await User.findOne({ role: 'admin' }, '-password -updatedAt -__v ');
            if (!admin) {
                return next(customErrorHandler.wrongCredentials())
            }
            res.status(200).json({ data: admin });
        } catch (err) {
            return next(customErrorHandler.serverError(err));
        }
    },

    async getUserSearch(req, res, next) {
        const { search } = req.params
        try {
            const data = await User.find({ $and: [{ name: { $regex: search, $options: "i" } }, { role: { $ne: 'admin' } }] }, '-password -updatedAt -__v ');
            if (!data) {
                return next(customErrorHandler.wrongCredentials());
            }
            res.status(200).json({ data });
        } catch (err) {
            return next(customErrorHandler.serverError(err));
        }
    },
    async getUserMessages(req, res, next) {
        const { id } = req.params;
        try {
            const userMessage = await User.aggregate([
                { $match: { role: {$ne: 'admin'}}},
                {
                    $lookup: {
                        from: 'messages',
                        // localField: '_id',
                        // foreignField: 'sender',
                        let: {id: '$_id'},
                        as: 'messages',
                        pipeline: [
                            {
                                 $match: {
                                      $expr:{
                                           $and:[
                                                {$eq: ["$seen",false]},
                                                {$eq: ['$$id', '$sender']}
                                           ]
                                      }
        
                                 },
                            }
                       ]
                        
                    }
                },
                {
                    $addFields: {
                        "unseenMessages": { $size: "$messages" }
                    }
                },
                {
                    $project: {
                     _id: 1,
                     name: 1,
                     unseenMessages: 1,
                    }
                 }

            ])
            if (!userMessage) {
                return next(customErrorHandler.emptyData());
            }
            res.status(200).json({ data: userMessage })

        } catch (err) {
            _639‍.g.console.log(err);
            return next(customErrorHandler.serverError(err))
        }
    }

}

_639‍.d(userController);  